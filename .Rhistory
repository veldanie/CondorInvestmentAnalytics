library(devtools)
install_github("veldanie/SuraInvestmentAnalytics")
library(reticulate)
library(xts)
library(knitr)
## Working directory:
rm(list=lsf.str());rm(list=ls(all=TRUE))
setwd("D:/Inversiones Internacionales Grupo Sura S.A/Daniel Velasquez Vergara - Proyecto Inception/shinyApp")
root_output <- "D:/OneDrive - Inversiones Internacionales Grupo Sura S.A/SuraInvestmentAnalytics/"
ref_date <- '20200803'
#1.PREPROC:-------------------------------------------------------------------------------------------------------------------
source("source/data_preproc.R", echo=FALSE)
freglob_rebuild <- function(ticker, asset_cf, fund_data, shift_values = NULL, as_div_yield = FALSE,
since_date = NULL, series_list = FALSE){
fund_cf <- xts(x = na.omit(as.numeric(asset_cf[, which(colnames(asset_cf) == ticker) + 1])),
order.by = na.omit(as.Date(asset_cf[, which(colnames(asset_cf) == ticker)], format = "%d/%m/%Y")))
if(!(series_list)){
fund_data <- xts(x = na.omit(as.numeric(fund_data[, which(colnames(fund_data) == ticker) + 1])),
order.by = na.omit(as.Date(fund_data[, which(colnames(fund_data) == ticker)], format = "%d/%m/%Y")))
}
if(!(is.null(since_date))){
fund_data <- fund_data[paste(toString(as.Date(since_date)), '/')]
}
if(!(is.null(shift_values))){
fund_returns <- xts::lag.xts(returns(fund_data), k = -shift_values)
}else{
fund_returns <- returns(fund_data)
}
if(as_div_yield){
div_yield <- fund_cf
}else{
div_yield <- fund_cf / fund_data[index(fund_cf), ]
}
delta_div_payments <- as.vector(mean(diff(index(div_yield))))
div_yield <- rbind(div_yield, xts(x = mean(coredata(div_yield)[(length(coredata(div_yield)) - 4):length(coredata(div_yield))]),
order.by = Sys.Date()))
for(i in 2:length(index(div_yield))){
if(i == length(index(div_yield))){
n_values <- delta_div_payments
}else{
n_values <- length(index(fund_data)[index(div_yield[i - 1]):index(div_yield[i])])
}
div_yield_nom <- convert_rates(div_yield[i], n_values - 1, 'Efectiva', 'Nominal') / n_values
fund_returns[paste(toString(index(div_yield[i - 1])), toString(index(div_yield[i])), sep = '/')] <- fund_returns[paste(toString(index(div_yield[i - 1])), toString(index(div_yield[i])), sep = '/')] + as.vector(div_yield_nom)
}
fund_series <- xts(x = as.vector(fund_data[1]) * cumprod(1 + c(0, coredata(fund_returns))),
order.by = index(fund_data))
if(!(is.null(shift_values))){
fund_series <- na.locf(fund_series)
}
return(fund_series)
}
convert_rates <- function(tasa_inicial, t, tipo_inicial, tipo_final) {
stopifnot(tipo_inicial != tipo_final) # Detiene la funci칩n si tipo_inicial == tipo_final
if (tipo_inicial == 'Efectiva') {
if (tipo_final == 'Continua') {
return(exp(tasa_inicial) - 1)
} else if (tipo_final == 'Nominal') {
return (t * ((tasa_inicial + 1) ^ (1 / t) - 1))
}
} else if (tipo_inicial == 'Nominal') {
if (tipo_final == 'Efectiva') {
return((1 + tasa_inicial / t) ^ t - 1)
} else if (tipo_final == 'Continua') {
return(exp((1 + tasa_inicial / t) ^ t - 1) - 1)
}
} else if (tipo_inicial == 'Continua') {
if (tipo_final == 'Efectiva') {
return(log(tasa_inicial + 1))
} else if (tipo_final == 'Nominal') {
return(log((t * ((tasa_inicial + 1) ^ (1 / t) - 1)) + 1))
}
} else {
print("No ha ingresado correctamente los par치metros, los tipos de tasa deben ser: Nominal, Efectiva o Continua")
}
}
prlat_rebuild <- function(ticker, series_list, reported_returns, since_date){
series <- series_list[[ticker]][paste0(since_date, '/')]
reported_returns <- xts(x = na.omit(reported_returns[, which(colnames(reported_returns) == ticker) + 1]),
order.by = na.omit(as.Date(reported_returns[, which(colnames(reported_returns) == ticker)], format = "%d/%m/%Y")))
series_returns <- returns(series)
for(i in 2:length(index(reported_returns))){
n_values <- length(series_returns[paste(toString(index(reported_returns[i - 1])), toString(index(reported_returns[i])), sep = '/')])
adjust_factor <- ((as.vector(series[index(reported_returns)[i - 1]]) * (1 + coredata(reported_returns)[i]) / as.vector(series[index(reported_returns)[i]]))) ^ (1 / n_values) - 1
series_returns[paste(toString(index(reported_returns[i - 1])), toString(index(reported_returns[i])), sep = '/')] <- series_returns[paste(toString(index(reported_returns[i - 1])), toString(index(reported_returns[i])), sep = '/')]  + adjust_factor
}
rebuilt_series <- xts(x = as.vector(series[1]) * cumprod(1 + c(0, coredata(series_returns))),
order.by = index(series))
output <- rbind(series_list[[ticker]][paste0('/', since_date)], rebuilt_series)
return(output)
}
#1.PREPROC:-------------------------------------------------------------------------------------------------------------------
source("source/data_preproc.R", echo=FALSE)
#2.SERIALIZE_DATA:--------------------------------------------------------------------------------------------------------------------------
knit("source/serialize_data_python_pickle.Rmd")
#3.UPDATE DB:----------------------------------------------------------------------------------------------------------------------
source("source/update_db.R", echo=FALSE)
#4. series_list to py:--------------------------------------------------------------------------------------------------------------------
knit("source/series_list_to_py.Rmd")
#5. UPLOAD PYTHON FILES TO S3:------------------------------------------------------------------------------------------------------------------
knit("source/boto3_s3.Rmd")
#3.UPDATE DB:----------------------------------------------------------------------------------------------------------------------
source("source/update_db.R", echo=FALSE)
library(reticulate)
library(xts)
library(knitr)
## Working directory:
rm(list=lsf.str());rm(list=ls(all=TRUE))
setwd("D:/Inversiones Internacionales Grupo Sura S.A/Daniel Velasquez Vergara - Proyecto Inception/shinyApp")
root_output <- "D:/OneDrive - Inversiones Internacionales Grupo Sura S.A/SuraInvestmentAnalytics/"
ref_date <- '20200803'
#1.PREPROC:-------------------------------------------------------------------------------------------------------------------
source("source/data_preproc.R", echo=FALSE)
prlat_rebuild <- function(ticker, series_list, reported_returns, since_date){
series <- series_list[[ticker]][paste0(since_date, '/')]
reported_returns <- xts(x = na.omit(reported_returns[, which(colnames(reported_returns) == ticker) + 1]),
order.by = na.omit(as.Date(reported_returns[, which(colnames(reported_returns) == ticker)], format = "%d/%m/%Y")))
series_returns <- returns(series)
for(i in 2:length(index(reported_returns))){
n_values <- length(series_returns[paste(toString(index(reported_returns[i - 1])), toString(index(reported_returns[i])), sep = '/')])
adjust_factor <- ((as.vector(series[index(reported_returns)[i - 1]]) * (1 + coredata(reported_returns)[i]) / as.vector(series[index(reported_returns)[i]]))) ^ (1 / n_values) - 1
series_returns[paste(toString(index(reported_returns[i - 1])), toString(index(reported_returns[i])), sep = '/')] <- series_returns[paste(toString(index(reported_returns[i - 1])), toString(index(reported_returns[i])), sep = '/')]  + adjust_factor
}
rebuilt_series <- xts(x = as.vector(series[1]) * cumprod(1 + c(0, coredata(series_returns))),
order.by = index(series))
output <- rbind(series_list[[ticker]][paste0('/', since_date)], rebuilt_series)
return(output)
}
freglob_rebuild <- function(ticker, asset_cf, fund_data, shift_values = NULL, as_div_yield = FALSE,
since_date = NULL, series_list = FALSE){
fund_cf <- xts(x = na.omit(as.numeric(asset_cf[, which(colnames(asset_cf) == ticker) + 1])),
order.by = na.omit(as.Date(asset_cf[, which(colnames(asset_cf) == ticker)], format = "%d/%m/%Y")))
if(!(series_list)){
fund_data <- xts(x = na.omit(as.numeric(fund_data[, which(colnames(fund_data) == ticker) + 1])),
order.by = na.omit(as.Date(fund_data[, which(colnames(fund_data) == ticker)], format = "%d/%m/%Y")))
}
if(!(is.null(since_date))){
fund_data <- fund_data[paste(toString(as.Date(since_date)), '/')]
}
if(!(is.null(shift_values))){
fund_returns <- xts::lag.xts(returns(fund_data), k = -shift_values)
}else{
fund_returns <- returns(fund_data)
}
if(as_div_yield){
div_yield <- fund_cf
}else{
div_yield <- fund_cf / fund_data[index(fund_cf), ]
}
delta_div_payments <- as.vector(mean(diff(index(div_yield))))
div_yield <- rbind(div_yield, xts(x = mean(coredata(div_yield)[(length(coredata(div_yield)) - 4):length(coredata(div_yield))]),
order.by = Sys.Date()))
for(i in 2:length(index(div_yield))){
if(i == length(index(div_yield))){
n_values <- delta_div_payments
}else{
n_values <- length(index(fund_data)[index(div_yield[i - 1]):index(div_yield[i])])
}
div_yield_nom <- convert_rates(div_yield[i], n_values - 1, 'Efectiva', 'Nominal') / n_values
fund_returns[paste(toString(index(div_yield[i - 1])), toString(index(div_yield[i])), sep = '/')] <- fund_returns[paste(toString(index(div_yield[i - 1])), toString(index(div_yield[i])), sep = '/')] + as.vector(div_yield_nom)
}
fund_series <- xts(x = as.vector(fund_data[1]) * cumprod(1 + c(0, coredata(fund_returns))),
order.by = index(fund_data))
if(!(is.null(shift_values))){
fund_series <- na.locf(fund_series)
}
return(fund_series)
}
convert_rates <- function(tasa_inicial, t, tipo_inicial, tipo_final) {
stopifnot(tipo_inicial != tipo_final) # Detiene la funci칩n si tipo_inicial == tipo_final
if (tipo_inicial == 'Efectiva') {
if (tipo_final == 'Continua') {
return(exp(tasa_inicial) - 1)
} else if (tipo_final == 'Nominal') {
return (t * ((tasa_inicial + 1) ^ (1 / t) - 1))
}
} else if (tipo_inicial == 'Nominal') {
if (tipo_final == 'Efectiva') {
return((1 + tasa_inicial / t) ^ t - 1)
} else if (tipo_final == 'Continua') {
return(exp((1 + tasa_inicial / t) ^ t - 1) - 1)
}
} else if (tipo_inicial == 'Continua') {
if (tipo_final == 'Efectiva') {
return(log(tasa_inicial + 1))
} else if (tipo_final == 'Nominal') {
return(log((t * ((tasa_inicial + 1) ^ (1 / t) - 1)) + 1))
}
} else {
print("No ha ingresado correctamente los par치metros, los tipos de tasa deben ser: Nominal, Efectiva o Continua")
}
}
library(reticulate)
library(xts)
library(knitr)
## Working directory:
rm(list=lsf.str());rm(list=ls(all=TRUE))
setwd("D:/Inversiones Internacionales Grupo Sura S.A/Daniel Velasquez Vergara - Proyecto Inception/shinyApp")
root_output <- "D:/OneDrive - Inversiones Internacionales Grupo Sura S.A/SuraInvestmentAnalytics/"
ref_date <- '20200803'
#1.PREPROC:-------------------------------------------------------------------------------------------------------------------
source("source/data_preproc.R", echo=FALSE)
freglob_rebuild <- function(ticker, asset_cf, fund_data, shift_values = NULL, as_div_yield = FALSE,
since_date = NULL, series_list = FALSE){
fund_cf <- xts(x = na.omit(as.numeric(asset_cf[, which(colnames(asset_cf) == ticker) + 1])),
order.by = na.omit(as.Date(asset_cf[, which(colnames(asset_cf) == ticker)], format = "%d/%m/%Y")))
if(!(series_list)){
fund_data <- xts(x = na.omit(as.numeric(fund_data[, which(colnames(fund_data) == ticker) + 1])),
order.by = na.omit(as.Date(fund_data[, which(colnames(fund_data) == ticker)], format = "%d/%m/%Y")))
}
if(!(is.null(since_date))){
fund_data <- fund_data[paste(toString(as.Date(since_date)), '/')]
}
if(!(is.null(shift_values))){
fund_returns <- xts::lag.xts(returns(fund_data), k = -shift_values)
}else{
fund_returns <- returns(fund_data)
}
if(as_div_yield){
div_yield <- fund_cf
}else{
div_yield <- fund_cf / fund_data[index(fund_cf), ]
}
delta_div_payments <- as.vector(mean(diff(index(div_yield))))
div_yield <- rbind(div_yield, xts(x = mean(coredata(div_yield)[(length(coredata(div_yield)) - 4):length(coredata(div_yield))]),
order.by = Sys.Date()))
for(i in 2:length(index(div_yield))){
if(i == length(index(div_yield))){
n_values <- delta_div_payments
}else{
n_values <- length(index(fund_data)[index(div_yield[i - 1]):index(div_yield[i])])
}
div_yield_nom <- convert_rates(div_yield[i], n_values - 1, 'Efectiva', 'Nominal') / n_values
fund_returns[paste(toString(index(div_yield[i - 1])), toString(index(div_yield[i])), sep = '/')] <- fund_returns[paste(toString(index(div_yield[i - 1])), toString(index(div_yield[i])), sep = '/')] + as.vector(div_yield_nom)
}
fund_series <- xts(x = as.vector(fund_data[1]) * cumprod(1 + c(0, coredata(fund_returns))),
order.by = index(fund_data))
if(!(is.null(shift_values))){
fund_series <- na.locf(fund_series)
}
return(fund_series)
}
convert_rates <- function(tasa_inicial, t, tipo_inicial, tipo_final) {
stopifnot(tipo_inicial != tipo_final) # Detiene la funci칩n si tipo_inicial == tipo_final
if (tipo_inicial == 'Efectiva') {
if (tipo_final == 'Continua') {
return(exp(tasa_inicial) - 1)
} else if (tipo_final == 'Nominal') {
return (t * ((tasa_inicial + 1) ^ (1 / t) - 1))
}
} else if (tipo_inicial == 'Nominal') {
if (tipo_final == 'Efectiva') {
return((1 + tasa_inicial / t) ^ t - 1)
} else if (tipo_final == 'Continua') {
return(exp((1 + tasa_inicial / t) ^ t - 1) - 1)
}
} else if (tipo_inicial == 'Continua') {
if (tipo_final == 'Efectiva') {
return(log(tasa_inicial + 1))
} else if (tipo_final == 'Nominal') {
return(log((t * ((tasa_inicial + 1) ^ (1 / t) - 1)) + 1))
}
} else {
print("No ha ingresado correctamente los par치metros, los tipos de tasa deben ser: Nominal, Efectiva o Continua")
}
}
prlat_rebuild <- function(ticker, series_list, reported_returns, since_date){
series <- series_list[[ticker]][paste0(since_date, '/')]
reported_returns <- xts(x = na.omit(reported_returns[, which(colnames(reported_returns) == ticker) + 1]),
order.by = na.omit(as.Date(reported_returns[, which(colnames(reported_returns) == ticker)], format = "%d/%m/%Y")))
series_returns <- returns(series)
for(i in 2:length(index(reported_returns))){
n_values <- length(series_returns[paste(toString(index(reported_returns[i - 1])), toString(index(reported_returns[i])), sep = '/')])
adjust_factor <- ((as.vector(series[index(reported_returns)[i - 1]]) * (1 + coredata(reported_returns)[i]) / as.vector(series[index(reported_returns)[i]]))) ^ (1 / n_values) - 1
series_returns[paste(toString(index(reported_returns[i - 1])), toString(index(reported_returns[i])), sep = '/')] <- series_returns[paste(toString(index(reported_returns[i - 1])), toString(index(reported_returns[i])), sep = '/')]  + adjust_factor
}
rebuilt_series <- xts(x = as.vector(series[1]) * cumprod(1 + c(0, coredata(series_returns))),
order.by = index(series))
output <- rbind(series_list[[ticker]][paste0('/', since_date)], rebuilt_series)
return(output)
}
freglob_rebuild <- function(ticker, asset_cf, fund_data, shift_values = NULL, as_div_yield = FALSE,
since_date = NULL, series_list = FALSE){
fund_cf <- xts(x = na.omit(as.numeric(asset_cf[, which(colnames(asset_cf) == ticker) + 1])),
order.by = na.omit(as.Date(asset_cf[, which(colnames(asset_cf) == ticker)], format = "%d/%m/%Y")))
if(!(series_list)){
fund_data <- xts(x = na.omit(as.numeric(fund_data[, which(colnames(fund_data) == ticker) + 1])),
order.by = na.omit(as.Date(fund_data[, which(colnames(fund_data) == ticker)], format = "%d/%m/%Y")))
}
if(!(is.null(since_date))){
fund_data <- fund_data[paste(toString(as.Date(since_date)), '/')]
}
if(!(is.null(shift_values))){
fund_returns <- xts::lag.xts(returns(fund_data), k = -shift_values)
}else{
fund_returns <- returns(fund_data)
}
if(as_div_yield){
div_yield <- fund_cf
}else{
div_yield <- fund_cf / fund_data[index(fund_cf), ]
}
delta_div_payments <- as.vector(mean(diff(index(div_yield))))
div_yield <- rbind(div_yield, xts(x = mean(coredata(div_yield)[(length(coredata(div_yield)) - 4):length(coredata(div_yield))]),
order.by = Sys.Date()))
for(i in 2:length(index(div_yield))){
if(i == length(index(div_yield))){
n_values <- delta_div_payments
}else{
n_values <- length(index(fund_data)[index(div_yield[i - 1]):index(div_yield[i])])
}
div_yield_nom <- convert_rates(div_yield[i], n_values - 1, 'Efectiva', 'Nominal') / n_values
fund_returns[paste(toString(index(div_yield[i - 1])), toString(index(div_yield[i])), sep = '/')] <- fund_returns[paste(toString(index(div_yield[i - 1])), toString(index(div_yield[i])), sep = '/')] + as.vector(div_yield_nom)
}
fund_series <- xts(x = as.vector(fund_data[1]) * cumprod(1 + c(0, coredata(fund_returns))),
order.by = index(fund_data))
if(!(is.null(shift_values))){
fund_series <- na.locf(fund_series)
}
return(fund_series)
}
convert_rates <- function(tasa_inicial, t, tipo_inicial, tipo_final) {
stopifnot(tipo_inicial != tipo_final) # Detiene la funci칩n si tipo_inicial == tipo_final
if (tipo_inicial == 'Efectiva') {
if (tipo_final == 'Continua') {
return(exp(tasa_inicial) - 1)
} else if (tipo_final == 'Nominal') {
return (t * ((tasa_inicial + 1) ^ (1 / t) - 1))
}
} else if (tipo_inicial == 'Nominal') {
if (tipo_final == 'Efectiva') {
return((1 + tasa_inicial / t) ^ t - 1)
} else if (tipo_final == 'Continua') {
return(exp((1 + tasa_inicial / t) ^ t - 1) - 1)
}
} else if (tipo_inicial == 'Continua') {
if (tipo_final == 'Efectiva') {
return(log(tasa_inicial + 1))
} else if (tipo_final == 'Nominal') {
return(log((t * ((tasa_inicial + 1) ^ (1 / t) - 1)) + 1))
}
} else {
print("No ha ingresado correctamente los par치metros, los tipos de tasa deben ser: Nominal, Efectiva o Continua")
}
}
prlat_rebuild <- function(ticker, series_list, reported_returns, since_date){
series <- series_list[[ticker]][paste0(since_date, '/')]
reported_returns <- xts(x = na.omit(reported_returns[, which(colnames(reported_returns) == ticker) + 1]),
order.by = na.omit(as.Date(reported_returns[, which(colnames(reported_returns) == ticker)], format = "%d/%m/%Y")))
series_returns <- returns(series)
for(i in 2:length(index(reported_returns))){
n_values <- length(series_returns[paste(toString(index(reported_returns[i - 1])), toString(index(reported_returns[i])), sep = '/')])
adjust_factor <- ((as.vector(series[index(reported_returns)[i - 1]]) * (1 + coredata(reported_returns)[i]) / as.vector(series[index(reported_returns)[i]]))) ^ (1 / n_values) - 1
series_returns[paste(toString(index(reported_returns[i - 1])), toString(index(reported_returns[i])), sep = '/')] <- series_returns[paste(toString(index(reported_returns[i - 1])), toString(index(reported_returns[i])), sep = '/')]  + adjust_factor
}
rebuilt_series <- xts(x = as.vector(series[1]) * cumprod(1 + c(0, coredata(series_returns))),
order.by = index(series))
output <- rbind(series_list[[ticker]][paste0('/', since_date)], rebuilt_series)
return(output)
}
library(reticulate)
library(xts)
library(knitr)
## Working directory:
rm(list=lsf.str());rm(list=ls(all=TRUE))
setwd("D:/Inversiones Internacionales Grupo Sura S.A/Daniel Velasquez Vergara - Proyecto Inception/shinyApp")
root_output <- "D:/OneDrive - Inversiones Internacionales Grupo Sura S.A/SuraInvestmentAnalytics/"
ref_date <- '20200803'
#1.PREPROC:-------------------------------------------------------------------------------------------------------------------
source("source/data_preproc.R", echo=FALSE)
#3.UPDATE DB:----------------------------------------------------------------------------------------------------------------------
source("source/update_db.R", echo=FALSE)
library(devtools)
install_github("veldanie/SuraInvestmentAnalytics")
load("D:/OneDrive - Inversiones Internacionales Grupo Sura S.A/SuraInvestmentAnalytics/data/asset_data.RData")
View(asset_data)
library(devtools)
install_github("veldanie/SuraInvestmentAnalytics")
library(quantmod)
